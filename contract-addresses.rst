==================
Contract Addresses
==================

Address generation
==================

CREATE1
-------
- Addresses generated by EOA accounts are made using the ``CREATE`` opcode. 
- Addresses generated by the ``CREATE`` opcode are deterministic and are based on the caller's `address` and `nonce`
- ``CREATE`` addresses are generated using the little endian result of the keccak256 hash of RLP encoded sender address and nonce
- Psuedo-code to calculate ``CREATE`` address is: ``keccak256(rlp.encode(senderAddress, senderNonce))[12:]``

CREATE2
-------
- Contract addresses can also be generated using the `CREATE2 <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md>`_ opcode
- Addresses generated using ``CREATE2`` opcode are deterministic and are based on the caller's `address` (often a contract address), a user defined `salt` and contract `initialization bytecode`
- One common pattern is to utilize a `CREATE2 Deployer contract <https://ftmscan.com/address/0x54f5a04417e29ff5d7141a6d33cb286f50d5d50e>`_
- The benefit to using ``CREATE2`` is that users have more control over address generation than they do with `CREATE`
- It is possible to use``CREATE2`` in a factory pattern to generate contracts with the same address across all chains
- Psuedo-code to calculate ``CREATE2`` address is: ``keccak256(0xff ++ senderAddress ++ salt ++ keccak256(init_code))[12:]``

Examples
========

Address calculation in solidity
-------------------------------

.. code-block:: javascript
    
    pragma solidity ^0.8.6;

    contract ContractAddressGenerator {
        function generateCreate1ContractAddress(address accountAddress, uint accountNonce) public pure returns (address) {
            if(accountNonce <= 0x7f) return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), accountAddress, uint8(accountNonce))))));
            if(accountNonce <= 0xff) return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), accountAddress, bytes1(0x81), uint8(accountNonce))))));
            if(accountNonce <= 0xffff) return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), accountAddress, bytes1(0x82), uint16(accountNonce))))));
            if(accountNonce <= 0xffffff) return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), accountAddress, bytes1(0x83), uint24(accountNonce))))));
            return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), accountAddress, bytes1(0x84), uint32(accountNonce)))))); // more than 2^32 nonces not realistic
        }

        function generateCreate2ContractAddress(address deployingContractAddress, bytes memory bytecode, uint salt) public pure returns (address) {
            bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(deployingContractAddress), salt, keccak256(bytecode)));
            return address(uint160(uint256(hash)));
        }
    }

CREATE2 Deployer
----------------

Deployed at: https://ftmscan.com/address/0x54f5a04417e29ff5d7141a6d33cb286f50d5d50e

.. code-block:: javascript

    pragma solidity 0.8.2;

    contract AnyswapCreate2Deployer {
        event Deployed(address addr, uint256 salt);

        function deploy(bytes memory code, uint256 salt) public {
            address addr;
            assembly {
            addr := create2(0, add(code, 0x20), mload(code), salt)
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
            }

            emit Deployed(addr, salt);
        }
    }

References
==========

- `Andre Cronje - Multichain Dapp Guide Standards and Best Practices <https://andrecronje.medium.com/multichain-dapp-guide-standards-and-best-practices-8fabe2672c60>`_
- `Stack Overflow - How is the address of an Ethereum contract created? <https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed>`_